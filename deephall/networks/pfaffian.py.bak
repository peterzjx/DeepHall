
from flax import linen as nn
import jax
from jax import numpy as jnp
from flax.training import train_state
import optax

from deephall.config import OrbitalType

from .blocks import Jastrow, Orbitals

class PairwiseNetwork(nn.Module):
    """Feedforward NN that maps (ri, rj) to a complex number."""
    hidden_dim: int = 64  # Adjustable hidden layer size

    @nn.compact
    def __call__(self, rij):
        """Forward pass: Input shape [batch, N_pairs, D] -> Output [batch, N_pairs, 2]"""
        x = nn.Dense(self.hidden_dim, use_bias=True)(rij)
        x = nn.softplus(x)  # Smooth activation

        # Second hidden layer
        x = nn.Dense(self.hidden_dim, use_bias=True)(x)
        x = nn.softplus(x)

        # Third hidden layer
        x = nn.Dense(self.hidden_dim, use_bias=True)(x)
        x = nn.softplus(x)

        # Output layer
        x = nn.Dense(2, use_bias=True)(x)
        return x[..., 0] + 1j * x[..., 1]


def extract_pairs(electron):
    """
    Generate unordered (ri, rj) pairs from electron coordinates.
    Returns: [Ne, Ne, D]
    D = length(features: ui, vi, ...)
    """
    theta, phi = electron[..., 0], electron[..., 1]
    u = (jnp.cos(theta / 2) * jnp.exp(0.5j * phi))[..., None]  # [N, 1]
    v = (jnp.sin(theta / 2) * jnp.exp(-0.5j * phi))[..., None]  # [N, 1]
    Ne, _ = electron.shape
    idx_i, idx_j = jnp.meshgrid(jnp.arange(Ne), jnp.arange(Ne), indexing='ij')

    # Gather the corresponding (ri, rj) pairs
    thetai = jnp.reshape(theta[idx_i], [-1])  # Shape: [Ne * Ne]
    phii = jnp.reshape(phi[idx_i], [-1])  # Shape: [Ne * Ne]
    thetaj = jnp.reshape(theta[idx_j], [-1])  # Shape: [Ne * Ne]
    phij = jnp.reshape(phi[idx_j], [-1])  # Shape: [Ne * Ne]
    ui = u[idx_i, 0]
    vi = v[idx_i, 0]
    uj = u[idx_j, 0]
    vj = v[idx_j, 0]
    zi = ui / vi
    zj = uj / vj
    zij = (zi - zj) 
    # print(zi.shape, zj.shape, zij.shape)
    ui = jnp.reshape(ui, [-1])
    vi = jnp.reshape(vi, [-1])
    zi = jnp.reshape(zi, [-1])

    uj = jnp.reshape(uj, [-1])
    vj = jnp.reshape(vj, [-1])
    zj = jnp.reshape(zj, [-1])

    
    angij = jnp.angle(zij)
    upper_i, upper_j = jnp.triu_indices(angij.shape[0], k=1)
    upper_ang = angij[upper_i, upper_j]
    # print(angij.shape)
    # print(upper_ang)
    # print(upper_i, upper_j)
    # re_angij = jnp.zeros_like(angij)
    # re_angij = re_angij.at[upper_i, upper_j].set(upper_ang)
    # print(re_angij)

    rij = jnp.expand_dims(jnp.abs(zij), axis=-1)
    angij = jnp.expand_dims(jnp.angle(zij), axis=-1)

    zij = jnp.reshape(zij, [-1])
    rhoij = jnp.abs(zij)
    feature = jnp.stack([thetai, phii, thetaj, phij], axis=-1)  # [Ne*Ne, D]
    # feature = jnp.stack([rhoij, angij], axis=-1)  # [Ne*Ne, D]
    rho_feature = jnp.stack([rhoij, rhoij**2, rhoij**3], axis=-1)  # [Ne*Ne, D]
    ang_feature = jnp.stack([angij, angij**2, angij**3], axis=-1)  # [Ne*Ne, D]
    # print(feature.shape, rho_feature.shape, ang_feature.shape)
    return feature, rho_feature, ang_feature, zij, vi*vj, ui*vj-uj*vi, rhoij, angij, upper_ang


def original_pfaf(electron):
    """Generate unordered (ri, rj) pairs from electron coordinates."""
    theta, phi = electron[..., 0], electron[..., 1]
    u = (jnp.cos(theta / 2) * jnp.exp(0.5j * phi))[..., None]  # [..., N, 1]
    v = (jnp.sin(theta / 2) * jnp.exp(-0.5j * phi))[..., None]  # [..., N, 1]
    Ne, _ = electron.shape
    pf_ij = (1 - jnp.eye(Ne)) / (u *
                                 v[:, 0] - u[:, 0] * v + jnp.eye(u.shape[0]) + 1e-10)  # [..., N, N]
    return pf_ij


class Pfaffian(nn.Module):
    nspins: tuple[int, int]
    Q: float
    ndets: int
    num_heads: int
    heads_dim: int
    num_layers: int
    orbital_type: OrbitalType

    @nn.compact
    def __call__(self, electrons: jnp.ndarray):
        # Using NN for wfn
        Ne = electrons.shape[0]
        pair_feature, rho_feature, ang_feature, zij,  vivj, uivj_ujvi, rhoij, angij, upper_ang = extract_pairs(electron=electrons)
        # rho_model = PairwiseNetwork()
        # rho_params = rho_model.init(jax.random.PRNGKey(
        #     42), rho_feature)  # Initialize model
        # rho_model_output = rho_model.apply(rho_params, rho_feature)  # Forward pass
        # g_ij = jnp.reshape(rho_model_output, [Ne, Ne])

        # ang_model = PairwiseNetwork()
        # ang_params = ang_model.init(jax.random.PRNGKey(
        #     42), ang_feature)  # Initialize model
        # ang_model_output = rho_model.apply(ang_params, ang_feature)  # Forward pass
        # phi_ang = jnp.reshape(ang_model_output, [Ne, Ne])
        
        vivj = jnp.reshape(vivj, [Ne, Ne])
        rhoij = jnp.reshape(rhoij, [Ne, Ne])
        upper_i, upper_j = jnp.triu_indices(rhoij.shape[0], k=1)
        re_angij = jnp.zeros_like(rhoij)
        re_angij = re_angij.at[upper_i, upper_j].set(upper_ang)
        angij = jnp.reshape(angij, [Ne, Ne])

        print(zij.shape)
        print(rhoij.shape)
        print(upper_ang.shape)
        print(re_angij.shape)
        # model = PairwiseNetwork()
        # params = model.init(jax.random.PRNGKey(
        #     42), zij)  # Initialize model
        # model_output = model.apply(params, zij)  # Forward pass
        # n_ij = jnp.reshape(model_output, [Ne, Ne])
        # # zij = jnp.reshape(zij, [Ne, Ne])
        # # vivj = jnp.reshape(vivj, [Ne, Ne])
        # # uivj_ujvi = jnp.reshape(uivj_ujvi, [Ne, Ne])
        # g_ij = (n_ij - n_ij.T) / 2  # Make it antisymmetric
        # # pfaffian = jnp.sqrt(jnp.linalg.det(( 1 - jnp.eye(Ne))  /(1e-10 + zij * vivj)))
    
        pfaffian = jnp.sqrt(jnp.linalg.det( ( 1 - jnp.eye(Ne)) /(1e-10 + rhoij * vivj * jnp.exp(re_angij) )))
        # print(pfaffian)
        # Using original Moore-Read Pfaffian for benchmarking
        # pfaf_ij = original_pfaf(electron=electrons)
        # pfaffian = jnp.sqrt(jnp.linalg.det(pfaf_ij))
        # print(pfaffian * self.flux_attachment(electrons))
        return jnp.log(self.flux_attachment(electrons) * pfaffian)

    @nn.compact
    def flux_attachment(self, electrons):
        """
            electrons: [..., N, 2]
        """
        theta, phi = electrons[..., 0], electrons[..., 1]

        u = (jnp.cos(theta / 2) * jnp.exp(0.5j * phi)
             )[..., None]  # [..., N, 1]
        v = (jnp.sin(theta / 2) * jnp.exp(-0.5j * phi)
             )[..., None]  # [..., N, 1]

        element = u * v[:, 0] - u[:, 0] * v + \
            jnp.eye(u.shape[0])  # [..., N, N]
        # uivj - ujvi + Î´ij == (zi-zj) for i!=j, 1 for i==j
        # Pfaffian wavefunction : Pf[G(vi, ui)] * Prod_{i<j}(zi-zj)**2
        #                       = Pf[G(vi, ui)] * Prod_{i,j}(element_ij)

        orbitals = jnp.prod(element, keepdims=False)  # [..., N, 1]
        # Prod_j (zi-zj), i!=j

        return orbitals


class PairFeaturedOrbitals(nn.Module):
    # nspins: tuple[int, int]
    features: list[int]

    @nn.compact
    def __call__(self, h_one):
        orbital_list = [
            nn.DenseGeneral(self.features)(h_one_alpha)
            + 1j * nn.DenseGeneral(self.features)(h_one_alpha)
            for h_one_alpha in jnp.split(h_one, (self.nspins[0],))
            if len(h_one_alpha)
        ]
        return jnp.concat(orbital_list)
    
class PairOrbitals(nn.Module):
    Q: float
    def setup(self):
        m = np.arange(-self.Q, self.Q + 1)
        self.norm_factor = jnp.array(np.sqrt(ss.comb(2 * self.Q, self.Q - m)))
        self.featured_orbitals = PairFeaturedOrbitals(
            features=(int(self.Q * 2) + 1),
        )

    def __call__(self, h_one, theta, phi):
        orbitals = self.featured_orbitals(h_one)

        m = jnp.arange(-self.Q, self.Q + 1)
        u = (jnp.cos(theta / 2) * jnp.exp(0.5j * phi))[..., None]
        v = (jnp.sin(theta / 2) * jnp.exp(-0.5j * phi))[..., None]
        envelope = self.norm_factor * u ** (self.Q + m) * v ** (self.Q - m)
        orbitals = jnp.sum(orbitals * envelope, axis=1)
        return orbitals  # Move ndets dim to the front