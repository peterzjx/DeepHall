
from flax import linen as nn
import jax
from jax import numpy as jnp
from flax.training import train_state
import optax

from deephall.config import OrbitalType

from .blocks import Jastrow, Orbitals




class PfafformerLayers(nn.Module):
    num_heads: int
    heads_dim: int
    num_layers: int

    @nn.compact
    def __call__(self, electrons: jnp.ndarray):
        theta, phi = electrons[..., 0], electrons[..., 1]  # [num, 2], [num, 2]
        h_one = self.input_feature(theta, phi)
        attention_dim = self.num_heads * self.heads_dim
        h_one = nn.Dense(attention_dim, use_bias=False)(h_one)
        for _ in range(self.num_layers):
            attn_out = nn.MultiHeadAttention(num_heads=self.num_heads)(h_one)
            h_one += nn.Dense(attention_dim, use_bias=False)(attn_out)
            h_one = nn.LayerNorm(epsilon=1e-5)(h_one)
            h_one += nn.tanh(nn.Dense(attention_dim)(h_one))
            h_one = nn.LayerNorm(epsilon=1e-5)(h_one)
        return h_one

    def input_feature(self, theta: jnp.ndarray, phi: jnp.ndarray):
        return jnp.stack(
            [
                jnp.cos(theta),
                jnp.sin(theta) * jnp.cos(phi),
                jnp.sin(theta) * jnp.sin(phi),
            ],
            axis=-1,
        )


def extract_pairs(electron):
    """
    Generate unordered (ri, rj) pairs from electron coordinates.
    Returns: [Ne, Ne, D]
    D = length(features: ui, vi, ...)
    """
    theta, phi = electron[..., 0], electron[..., 1]
    Ne, _ = electron.shape
    idx_i, idx_j = jnp.meshgrid(jnp.arange(Ne), jnp.arange(Ne), indexing='ij')
    

    # Gather the corresponding (ri, rj) pairs
    # thetai = jnp.reshape(theta[idx_i], [-1])  # Shape: [Ne * Ne]
    # phii = jnp.reshape(phi[idx_i], [-1])  # Shape: [Ne * Ne]
    # thetaj = jnp.reshape(theta[idx_j], [-1])  # Shape: [Ne * Ne]
    # phij = jnp.reshape(phi[idx_j], [-1])  # Shape: [Ne * Ne]
    
    thetai = theta[idx_i]  # Shape: [Ne * Ne]
    phii = phi[idx_i] # Shape: [Ne * Ne]
    thetaj = theta[idx_j] # Shape: [Ne * Ne]
    phij = phi[idx_j] # Shape: [Ne * Ne]
    
    
    upper_i, upper_j = jnp.triu_indices(thetai.shape[0], k=1)
    upper_theta_i = thetai[upper_i, upper_j]
    upper_theta_j = thetaj[upper_i, upper_j]
    upper_phi_i = phii[upper_i, upper_j]
    upper_phi_j = phij[upper_i, upper_j]

    theta_pair = jnp.stack([upper_theta_i, upper_theta_j], axis=-1)  # [Ne*(Ne-1)/2, 2]
    phi_pair = jnp.stack([upper_phi_i, upper_phi_j], axis=-1)  # [Ne*(Ne-1)/2, 2]
    pair_feature = jnp.stack([theta_pair, phi_pair], axis=-1)  # [Ne*(Ne-1)/2, 2, 2]

    # [B, (i, j), (theta, phi)]
    
    return pair_feature, upper_i, upper_j


def original_pfaf(electron):
    """Generate unordered (ri, rj) pairs from electron coordinates."""
    theta, phi = electron[..., 0], electron[..., 1]
    u = (jnp.cos(theta / 2) * jnp.exp(0.5j * phi))[..., None]  # [..., N, 1]
    v = (jnp.sin(theta / 2) * jnp.exp(-0.5j * phi))[..., None]  # [..., N, 1]
    Ne, _ = electron.shape
    pf_ij = (1 - jnp.eye(Ne)) / (u *
                                 v[:, 0] - u[:, 0] * v + jnp.eye(u.shape[0]) + 1e-10)  # [..., N, N]
    return pf_ij


class Pfaffian(nn.Module):
    nspins: tuple[int, int]
    Q: float
    ndets: int
    num_heads: int
    heads_dim: int
    num_layers: int
    orbital_type: OrbitalType
    benchmark_original: bool = False

    @nn.compact
    def __call__(self, electrons: jnp.ndarray):
        # Using NN for wfn
        Ne = electrons.shape[0]
        electron_pair, upper_i, upper_j = extract_pairs(electron=electrons)
        theta, phi = electron_pair[..., 0], electron_pair[..., 1]
        pair_num = Ne * (Ne-1) // 2 
        # print("electron_pair", electron_pair.shape, theta.shape, phi.shape)
        
        # electron_pair: [pair_num, 2, 2]
        # theta: [pair_num, 2]
        # phi: [pair_num, 2]
        # h_one: [pair_num, 2, feature]
        h_one = PfafformerLayers(
            num_heads=self.num_heads,
            num_layers=self.num_layers,
            heads_dim=self.heads_dim,
        )(electron_pair) 

        pair_orbs = jnp.zeros(pair_num, dtype=jnp.complex64)
        for i in jnp.arange(0, pair_num):
            pair_orb = self.orbitals(h_one[i], theta[i], phi[i])
            # signs, logdets = jnp.linalg.slogdet(pair_orb)
            # logmax = jnp.max(logdets)  # logsumexp trick
            # pair_orbs = pair_orbs.at[i].set(jnp.log(jnp.sum(signs * jnp.exp(logdets - logmax))) + logmax)
            dets = jnp.linalg.det(pair_orb)
            pair_orbs = pair_orbs.at[i].set(jnp.sum(dets))
        pfaf_ij = jnp.zeros([Ne, Ne], dtype=jnp.complex64)
        pfaf_ij = pfaf_ij.at[upper_i, upper_j].set(pair_orbs)
        pfaf_ij = pfaf_ij - pfaf_ij.T
        # orig_pfaf_ij = original_pfaf(electron=electrons)
        pfaffian = jnp.sqrt(jnp.linalg.det(pfaf_ij))
        # pfaffian = jnp.sqrt(jnp.linalg.det(pfaf_ij * orig_pfaf_ij))
        if self.benchmark_original:
            # Using original Moore-Read Pfaffian for benchmarking
            pfaf_ij = original_pfaf(electron=electrons)
            # pfaffian = jnp.sqrt(jnp.linalg.det(pfaf_ij))
        cf_flux = self.flux_attachment(electrons)
        return jnp.log(pfaffian * cf_flux)

    @nn.compact
    def orbitals(self, h, theta, phi):
        Ne = theta.shape[0]
        orbitals = Orbitals(
                type=self.orbital_type, Q=self.Q - 2 * (Ne - 1), nspins=(2, 0), ndets=self.ndets
            )(h, theta, phi)
        return orbitals

    @nn.compact
    def flux_attachment(self, electrons):
        """
            electrons: [..., N, 2]
        """
        theta, phi = electrons[..., 0], electrons[..., 1]

        u = (jnp.cos(theta / 2) * jnp.exp(0.5j * phi)
             )[..., None]  # [..., N, 1]
        v = (jnp.sin(theta / 2) * jnp.exp(-0.5j * phi)
             )[..., None]  # [..., N, 1]

        element = u * v[:, 0] - u[:, 0] * v + \
            jnp.eye(u.shape[0])  # [..., N, N]
        # uivj - ujvi + Î´ij == (zi-zj) for i!=j, 1 for i==j
        # Pfaffian wavefunction : Pf[G(vi, ui)] * Prod_{i<j}(zi-zj)**2
        #                       = Pf[G(vi, ui)] * Prod_{i,j}(element_ij)

        orbitals = jnp.prod(element, keepdims=False)  # [..., N, 1]
        # Prod_j (zi-zj), i!=j

        return orbitals
